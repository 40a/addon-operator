# Values storage

The Addon-operator provides storage for the values that will be passed to the helm chart. You may find out more about the values concept in the helm documentation: [values files](https://helm.sh/docs/chart_template_guide/#values-files). Global and module hooks also have access to the values in the storage and can change them.

The values storage is a hash-like data structure. The global key contains all global values – they are passed to every hook and available to helm charts. Only global hooks may change global values.

The other keys must be (names of modules)[MODULES.md#structure-overview] in the form of camelCase. Every key stores the object with module values – they are only available to the hooks and enabled script of this module as well as its helm chart. Only module hooks can change the values of the module.

Note: You cannot get the values of another module within the module hook. You need to use global storage for shared values.

The object with values may be:

- a structure (including empty structure)
- a list (including empty list)
- a boolean value (true or false)

Structures and lists must be JSON-compatible since hooks get the parameters in the JSON files (see [parameters in hooks](#work-with-values-in-hooks).

Boolean values are for enable and disable the module; this case is handled in [modules discovery](LIFECYCLE.md#modules-discovery).

# values.yaml

On start-up, the Addon-operator loads values into storage from `values.yaml` files:

- $MODULES_DIR/values.yaml — the values from `global` key only
- `values.yaml` files in modules directories — the values from key with camelCase name of the module

An example of global values in $MODULES_DIR/values.yaml:

```
global:
  param1: value1
  param2: value2
```

An example of module values in $MODULES_DIR/001-simple-module/values.yaml:

```
simpleModule:
  modParam1: value1
  modParam2: value2
```

# ConfigMap/addon-operator

There is a key `global` in the ConfigMap/addon-operator that contains global values and a keys with module values. The values stored in these keys are storead as string with yaml-coded parameters. Values in the ConfigMap/addon-operator override the values that loaded from values.yaml files.

Addon-operator monitors changes in the ConfigMap/addon-operator and starts [modules discovery](LIFECYCLE#modules-discovery) process in the case of parameters change.

An example of ConfigMap/addon-operator:

```
data:
  global: |                 # vertical bar is required here
    param1: newValue
    param3: valu3
  simpleModule: |           # module name should be in camelCase
    modParam2: newValue2
  anotherModule: "false"    # false value is disabled a module
```

# Update values

Hooks have the ability to update values in the storage. In order to do that a hook returns [json-patch](http://jsonpatch.com/).

A hook can update values in the ConfigMap/addon-operator so that the updated values would be available after the restart of the Addon-operator (long-term update). For example, you may store generated passwords or certificates.

Patch for a long-term update is returned via the $CONFIG_VALUES_JSON_PATCH_PATH file and after hook execution Addon-operator immediately updates the values in ConfigMap/addon-operator.

Another option is to update values for a time while Addon-operator process is running. For example, you may store the results of the discovery of cluster resources or changing parameters of the cluster.

Patches for temporary updates are returned via $VALUES_JSON_PATCH_PATH files and remain in the Addon-operator memory.

# Merged values

A merged set of values is generated by Addon-operator when hooks or enabled-scripts are executed or when helm charts are installed. In order to do that the global values are combined with the module values from the values.yaml and ConfigMap/addon-operator, and then the patches for the temporary update are applied.

Next, the merged values are passed as the temporary JSON file to hooks or enabled-script and as a temporary values.yaml file to the helm chart.

# Using values in hook

When the hook is triggered by an event, the parameters are passed to it via JSON files:

$CONFIG_VALUES_PATH — a path to a file with values from the ConfigMap/addon-operator

$VALUES_PATH — a path to a file with merged values


For global hooks, only the global values are available.

For module hooks the global values and the module values are available. Also, the enabledModules field is added to the global values in the $VALUES_PATH file. It contains the list of all enabled modules in order of execution (see [module lifecycle](LIFECYCLE.md#module-lifecycle)).

To change the values, the hook must return JSON patches via the following files:

$CONFIG_VALUES_JSON_PATCH_PATH — a patch for ConfigMap/addon-operator.

$VALUES_JSON_PATCH_PATH — a patch for a temporary update of parameters.

# Using values in enabled-scripts

The `enabled` script works with values in the read-only mode. It receives values in following JSON files:

$CONFIG_VALUES_PATH — a path to a file with values from the ConfigMap/addon-operator

$VALUES_PATH — a path to a file with merged values

The `enabledModules` field with the list of previously enabled modules is added to the $VALUES_PATH.


# Using parameters in the templates of helm charts

Helm chart of the module has access to a merged values similar to the $VALUES_PATH but without `enabledModules` field.

The variable `.Values` allows you to use values in the templates:

```
{{ .Values.global.param1 }}

{{ .Values.moduleName.modParam2 }}
```


# Example

Let’s assume the following parameters are defined:

```
$ cat modules/values.yaml:

global:
  param1: 100
  param2: "Yes"

$ cat modules/01-some-module/values.yaml

someModule:
  param1: "String"

$ kubectl -n addon-operator get cm/addon-operator -o yaml

data:
  global: |
    param1: 200
  someModule: |
    param1: "Long string"
    param2: "FOO"
```


Addon-operator generates the following files with values:

```
$ cat $CONFIG_VALUES_PATH

{"global":{
    "param1":200
}, "someModule":{
    "param1":"Long string",
    "param2": "FOO"
}}

$ cat $VALUES_PATH

{"global":{
    "param1":200,
    "param2": "YES"
}, "someModule":{
    "param1":"Long string", 
    "param2": "FOO"
}}

```

A hook adds a new value with the help of a JSON patch:

```
cat > $CONFIG_VALUES_JSON_PATCH_PATH <<EOF
  [{"op":"add", "path":"/someModule/param3", "value":"newValue"}]
EOF
```

Now the ConfigMap/addon-operator has the following contents:

```
data:
  global: |
    param1: 200
  someModule: |
    param1: "Long string"
    param2: "FOO"
    param3: "newValue"
```

The next time the hook is executed, Addon-operator would generate the following files with parameters:


```
$ cat $CONFIG_VALUES_PATH

{"global":{
     "param1":200
},
"someModule":{
    "param1":"Long string",
    "param2": "FOO",
    "param3": "newValue"
}}

$ cat $VALUES_PATH

{"global":{
    "param1":200,
    "param2": "YES"
}, "someModule":{
    "param1":"Long string",
    "param2": "FOO",
    "param3": "newValue"
}}
```

Helm chart template string...


```
replicas: {{ .Values.global.param1 }}
```

... would generate the string `replicas: 200`. As you can see, the value 100 from the values.yaml is replaced by 200 from the ConfigMap/addon-operator.

